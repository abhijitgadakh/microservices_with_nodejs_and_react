//---------------- 1. App Overview

Now that we've covered the communication patterns with microservices, we’re diving into actual code.

Goal of this project: 
- Get hands-on experience with microservices architecture.
- Build as much as possible from scratch to understand what’s going on.

This is a simple application to showcase the patterns:
- It's not meant to be a template for future projects because in real-world projects we use packages instead of building everything manually.
- This application is just a starting point. A more complex project will come later in the course.

What are we building?
- A simple blog-like application where users can create posts and add comments to them.
- Posts will only have titles for simplicity (no body content).
- After creating a post, the title will be displayed with the number of comments.
- Users can add comments, and the number of comments for each post will increment.

Technical Breakdown:
- We’ll need two types of services: 
  - Post Service: Handles creating and listing posts.
  - Comment Service: Handles creating and listing comments.

Service Responsibilities:
- Post Service: 
  - Create a post
  - List all posts
- Comment Service: 
  - Create a comment tied to a specific post
  - List comments associated with a post

Hidden Complexity:
- The Comment Service will have complexity because it needs to link comments to posts.
- To create a comment, the system needs to know what posts exist, so it will need to use asynchronous or synchronous communication.
- When listing comments, they should be filtered by the posts they are tied to (i.e., retrieving comments for the top 10 most popular posts).

Even though the app seems simple, the underlying structure will introduce challenges. These complexities will become clearer as we start implementing the services.


//---------------- 2. Project Setup

We are starting to set up our project and will quickly review the architecture and initial setup steps.

Architecture Overview:
- The browser will run a React application.
- The React application communicates with two services via network requests:
  - Post Service
  - Comment Service
- Both services are Express-based applications.
- For this project, data will be stored in memory (no databases) to keep the focus on understanding communication patterns.

Setup Plan:
1. Create a React application using Create React App.
2. Scaffold two Express-based services: Post Service and Comment Service.
3. Use three terminal windows to manage the setup:
   - One for the React client.
   - One for the Post Service.
   - One for the Comment Service.

Steps:
- In the terminal, navigate to your workspace directory and create a folder named `blog` to hold the entire project.
- Generate the React application:
  - Run `npx create-react-app client` to create the client directory for the React app.
- While the React app installs, set up the Post Service:
  - Create a `posts` folder inside the `blog` directory.
  - Navigate to the `posts` folder.
  - Initialize a `package.json` file using `npm init -y`.
  - Install dependencies: `npm install express cors axios nodemon`.
- Repeat the same process for the Comment Service:
  - Create a `comments` folder inside the `blog` directory.
  - Navigate to the `comments` folder.
  - Initialize a `package.json` file using `npm init -y`.
  - Install dependencies: `npm install express cors axios nodemon`.

Managing Terminal Windows:
- Ensure you have three terminal windows:
  - One in the `client` directory for the React app.
  - One in the `posts` directory for the Post Service.
  - One in the `comments` directory for the Comment Service.
- Keep track of which terminal window corresponds to which part of the project.

Note:
- Managing multiple terminal windows can be confusing, so stay organized and aware of the active terminal.
- To simplify switching between windows, you might consider tiling them for better visibility in the next steps.

This concludes the initial setup. We'll begin writing code in the upcoming steps.


//---------------- 3. Posts Service Creation

We have done some initial setup and are ready to start writing our services for the implementation.

For now, we will focus on basic functionality for the Post service.

The goal is to:
- Create a post.
- List all posts.

Key routes for the Post service:
1. A route to retrieve all posts (GET /posts).
2. A route to create a new post (POST /posts).

Plan:
- Use Express to build a small application.
- Define two route handlers.
- Store posts in memory (not using a database for this toy project).

Steps:
1. Require Express and create an application.
2. Define the two routes: GET /posts and POST /posts.
3. Set up the application to listen on port 4000.
4. Implement an in-memory object to store posts.
5. Handle GET requests by sending all posts.
6. Handle POST requests by:
   - Generating a random ID for the new post using the `crypto` module's `randomBytes` function.
   - Extracting the title from the request body.
   - Adding the new post to the in-memory object.
   - Responding with the newly created post's ID.
7. Add a body parser middleware to parse JSON data in incoming requests.

Implementation notes:
- Create a file (index.js) to write the code.
- Use `body-parser` middleware for JSON handling.
- Add a script to package.json to start the application with `nodemon`.

Final steps:
- Test the service after implementation.
- Verify it is running on port 4000 by checking the logs.


//---------------- 4. Testing the Posts Service

We've now finished up our first post service.

It's time to test this manually before diving into automated testing later in the course. Automated testing is crucial for microservices, and we’ll cover it in detail as we proceed. For now, we'll use manual testing to ensure the service is functioning as expected.

To test the service manually, we’ll use Postman, a desktop application that allows you to make arbitrary API requests to any endpoint. If you don’t want to use Postman, you can use an alternative, but Postman simplifies the process significantly.

If you don’t already have Postman installed, download it from postman.com. Once installed, open Postman, and you’ll see its main interface. Here’s how we’ll test the post service:

1. Open a new tab in Postman to customize an API request.
2. Set the HTTP method to POST and the URL to `http://localhost:4000/posts`.
3. Navigate to the Headers tab and add a new header with:
   - Key: `Content-Type`
   - Value: `application/json`
4. Go to the Body tab and select the “raw” option. Ensure the dropdown on the right is set to JSON.
5. Write JSON data in the request body. For example:
   ```json
   {
       "title": "First Post"
   }
   ```
6. Send the request. You should receive a response with status `201 Created` and a JSON object containing the ID and title of the post you just created.

Next, test retrieving all posts:

1. Open another new tab in Postman.
2. Set the HTTP method to GET and the URL to `http://localhost:4000/posts`.
3. In the Headers tab, ensure the `Content-Type` header is set to `application/json`.
4. Send the request. You should see a JSON response with all the posts created so far.

Be mindful that the service stores posts in memory. If you make any code changes, the server will restart, and all posts will be lost. For example, adding a simple comment and saving the file will trigger a restart (if using Nodemon). If you then make a GET request, no posts will be returned.

While manual testing is a good start, we’ll rely on automated testing as we build more services. In the next video, we’ll start developing the comment service. You’ll be encouraged to test it with Postman as we’ve done here to verify functionality.

//---------------- 5. Implementing a Comments Service

We finished up our post service, so now we're going to put together an initial implementation of our comments service.

Just as we did before, it's worth our time to thoroughly define what we want our comments service to do. 

For the comments service, we'll have two different route handlers:
1. A handler to create a new comment associated with a specific post. This involves:
   - Making a POST request to `post/:id/comments`.
   - Including a request body with a `content` field for the comment text.
2. A handler to retrieve all comments for a specific post. This involves:
   - Making a GET request to `post/:id/comments`.

The comments service will require some additional complexity in its design. We'll store comments in an in-memory data structure called `commentsByPostId`, optimized for retrieving all comments associated with a specific post.

Implementation Plan

1. Setup
   - Create an `index.js` file in the `comments` directory.
   - Import the necessary libraries: `express`, `body-parser`, and `crypto` for generating random IDs.
   - Initialize an Express app and configure `body-parser` as middleware.

2. Define Routes
   - Implement a POST route at `/post/:id/comments` to handle new comment creation:
     - Generate a unique comment ID using `crypto.randomBytes`.
     - Extract the `content` from the request body.
     - Check if comments exist for the given post ID in `commentsByPostId`. If not, initialize an empty array.
     - Add the new comment (ID and content) to the array and update the `commentsByPostId` object.
     - Return the updated array of comments.
   - Implement a GET route at `/post/:id/comments` to retrieve comments for a specific post:
     - Look up the post ID in `commentsByPostId`.
     - If no comments are found, return an empty array.
     - Respond with the array of comments.

3. Start Server
   - Ensure the server listens on a unique port (e.g., `4001`) since the post service is already using `4000`.
   - Log a confirmation message when the server starts.

4. Data Structure Overview
   - The `commentsByPostId` object will have:
     - Keys representing post IDs.
     - Values as arrays containing comments for the corresponding post.
   - This design allows quick retrieval of all comments for a specific post.

Example Data Flow

For a post ID `123`:
- `commentsByPostId` might look like this:
  ```json
  {
      "123": [
          { "id": "c1", "content": "Great post!" },
          { "id": "c2", "content": "Thanks for sharing." }
      ]
  }
  ```

5. Testing
   - Use Postman to manually test the POST and GET endpoints:
     - For POST: Verify that new comments are added correctly.
     - For GET: Confirm retrieval of all comments for a post.
   - Ensure appropriate response statuses (e.g., `201 Created` for POST).

In the next steps, we'll perform manual testing using Postman and refine the service based on observed behavior. Automated testing will follow later in the course.

//---------------- 6. Quick Comments Test

Our combat service is all complete, so let's very quickly do a quick test using Postman. Start by flipping back over to the terminal to get started.

1. Find the terminal window inside the comments project directory and start the service.
2. Recall that there are two separate services running on your machine:
   - One listening on Port 4000.
   - The other listening on Port 4001.

To communicate with the comments service, make requests to localhost:4001.

Testing with Postman

1. Post Request to Create a Comment
   - Open Postman and create a new request tab.
   - Set the request type to POST.
   - Enter the URL: `http://localhost:4001/posts/123/comments`. The post ID `123` can be any string for testing since the service doesn’t validate IDs.
   - Add headers:
     - `Content-Type: application/json`.
   - In the Body section:
     - Select `Raw` and ensure the dropdown is set to JSON.
     - Add JSON content, for example:
       ```json
       {
           "content": "I am a comment"
       }
       ```
   - Send the request. A successful response (201 Created) should include an array of comments for the post ID.

2. Get Request to Retrieve Comments
   - Open another request tab in Postman.
   - Set the request type to GET.
   - Enter the URL: `http://localhost:4001/posts/123/comments`.
   - Add headers:
     - `Content-Type: application/json`.
   - Send the request. A successful response (200 OK) should return an array of comments for the given post ID.

3. Add Additional Comments
   - Go back to the POST request tab.
   - Update the comment content to "Second comment".
   - Send the request again. The response should now show two comments.
   - Verify by returning to the GET request tab and sending the request again to ensure all comments are retrieved.

Notes

- The comments service correctly handles adding multiple comments without overwriting existing ones.
- This concludes basic testing with Express.js.

In the next session, we'll build the React application. During this process, potential design issues in our current implementation will become evident. We'll address these problems using a microservices approach to improve efficiency and scalability.


//---------------- 7. React Project Setup

We've now got our two services put together, so now it's time to start working on our React application.

If you don't know React or don't want to work with it, you can skip these videos and download the completed React app in a couple of videos. Any changes required to the React project later will be minimal.

Component Design
The app will have the following component hierarchy:
- `App`: The top-level component.
- `PostCreate`: Displays the form for creating posts.
- `PostList`: Displays all posts.
- `CommentList`: Displays comments associated with a post.
- `CommentCreate`: Displays the form for creating comments.

Each component will have its specific responsibilities:
- `PostCreate` handles creating posts.
- `PostList` shows posts and integrates `CommentList` and `CommentCreate` for each post.
- `CommentList` lists all comments for a post.
- `CommentCreate` handles adding new comments.

Setting Up the Project
1. Navigate to the `client` directory where the React project is located.
2. Open your code editor inside this directory.
3. Run `npm install` to install dependencies. Install Axios for making API requests:
   ```bash
   npm install axios
   ```
4. Start the React development server:
   ```bash
   npm start
   ```

Cleaning Up
1. Open the `src` directory and delete all boilerplate code to start from scratch.
2. Create the following files in `src`:
   - `index.js`
   - `App.js`

Building the Application
#`App.js`
```jsx
import React from "react";

const App = () => {
    return <div>Blog App</div>;
};

export default App;
```

#`index.js`
```jsx
import React from "react";
import ReactDOM from "react-dom";
import App from "./App";

ReactDOM.render(<App />, document.getElementById("root"));
```

Testing the Setup
1. Restart the development server to apply the changes.
2. Ensure that the app renders the text "Blog App" in the browser.

This concludes the initial setup. Next, we’ll start implementing the component hierarchy and connecting our React app to the Express APIs.


//---------------- 8. Building Post Submission

We've now got our two services put together, so now it's time to start working on our React application.

If you don't know React or don't want to work with it, you can skip these videos and download the completed React app in a couple of videos. Any changes required to the React project later will be minimal.

Component Design
The app will have the following component hierarchy:
- `App`: The top-level component.
- `PostCreate`: Displays the form for creating posts.
- `PostList`: Displays all posts.
- `CommentList`: Displays comments associated with a post.
- `CommentCreate`: Displays the form for creating comments.

Each component will have its specific responsibilities:
- `PostCreate` handles creating posts.
- `PostList` shows posts and integrates `CommentList` and `CommentCreate` for each post.
- `CommentList` lists all comments for a post.
- `CommentCreate` handles adding new comments.

Setting Up the Project
1. Navigate to the `client` directory where the React project is located.
2. Open your code editor inside this directory.
3. Run `npm install` to install dependencies. Install Axios for making API requests:
   ```bash
   npm install axios
   ```
4. Start the React development server:
   ```bash
   npm start
   ```

Cleaning Up
1. Open the `src` directory and delete all boilerplate code to start from scratch.
2. Create the following files in `src`:
   - `index.js`
   - `App.js`

Building the Application
#`App.js`
```jsx
import React from "react";

const App = () => {
    return <div>Blog App</div>;
};

export default App;
```

#`index.js`
```jsx
import React from "react";
import ReactDOM from "react-dom";
import App from "./App";

ReactDOM.render(<App />, document.getElementById("root"));
```

Testing the Setup
1. Restart the development server to apply the changes.
2. Ensure that the app renders the text "Blog App" in the browser.

Creating the PostCreate Component
1. In the `src` directory, create a new file `PostCreate.js`.
2. Implement the component as follows:

#`PostCreate.js`
```jsx
import React, { useState } from "react";
import axios from "axios";

const PostCreate = () => {
    const [title, setTitle] = useState("");

    const onSubmit = async (event) => {
        event.preventDefault();
        await axios.post("http://localhost:4000/posts", { title });
        setTitle("");
    };

    return (
        <div>
            <form onSubmit={onSubmit}>
                <div className="form-group">
                    <label>Title</label>
                    <input
                        value={title}
                        onChange={(e) => setTitle(e.target.value)}
                        className="form-control"
                    />
                </div>
                <button className="btn btn-primary">Submit</button>
            </form>
        </div>
    );
};

export default PostCreate;
```

3. Update `App.js` to include `PostCreate`:

#`App.js`
```jsx
import React from "react";
import PostCreate from "./PostCreate";

const App = () => {
    return (
        <div className="container">
            <h1>Create Post</h1>
            <PostCreate />
        </div>
    );
};

export default App;
```

Adding Bootstrap
1. Link Bootstrap CSS in `public/index.html`:
```html
<link
    href="https://cdn.jsdelivr.net/npm/bootstrap@5.1.3/dist/css/bootstrap.min.css"
    rel="stylesheet"
    integrity="sha384-1BmE4kWBq78iYhFldvKuhfTAU6auUHI6WlZKmIOTa1HsENBO0LRn5q+8nbTov4+1"
    crossorigin="anonymous"
/>
```

2. Add a `container` class to the main `div` in `App.js` to constrain the layout.

Testing PostCreate
1. Open the browser’s developer tools and navigate to the network tab.
2. Create a post by entering a title and clicking submit.
3. Check for a POST request to `http://localhost:4000/posts`.
4. If there’s a CORS error, this will be addressed in the next video.

This concludes the implementation of the `PostCreate` component.


//---------------- 9. Handling CORS Errors

In the last video, we tried to create a new post but encountered a CORS request error.

CORS (Cross-Origin Resource Sharing) issues arise when we try to make a request to a domain or port different from our own. 

For example, our React app runs on localhost:3000, and we are making a POST request to localhost:4000. Since the ports are different, the browser automatically blocks the request unless the server (localhost:4000) provides specific headers.

This issue cannot be resolved by modifying the browser or React app. The solution lies in configuring the server.

Steps to fix the issue:
1. Stop both the Post and Comment services in the terminal.
2. Install the `cors` package for both services by running:

This package helps by setting the necessary headers to bypass the CORS restriction.

3. Restart the Post and Comment services after installation.

4. Open the code editor for the Post service. In the `index.js` file:
- Require the `cors` module at the top of the file:
  ```javascript
  const cors = require('cors');
  ```
- Use it as middleware in the Express app:
  ```javascript
  app.use(cors());
  ```
- Ensure the `cors` function is called as a function.

5. Repeat the same steps for the Comment service:
- Require `cors` at the top.
- Use it as middleware:
  ```javascript
  app.use(cors());
  ```

6. Save the changes and restart the services.

Testing:
- Go back to the browser and refresh the page.
- Try creating a post again. If successful, the browser will no longer show CORS errors, and the response should return a status code of 201, indicating the post was created successfully.

For future services:
- Add the `cors` middleware from the start to avoid similar issues.

In upcoming projects:
- Architectural changes will prevent cross-origin requests, as APIs and frontends will be co-located.

Next steps:
- Begin working on the posts component.
- Add functionality to list and create comments.


//---------------- 10. Fetching and Rendering Posts

We are working on PostList, CommentList, and CommentCreate components.
These components are required to interact with React and will expose architectural issues in our microservices setup later on.

To start, create a new file named `PostList.js` inside the `src` directory.
- Import React at the top.
- Create a functional component and export it as default.
- Initially, return an empty `<div>`.

Update `App.js` to display the `PostList` component:
- Import `PostList`.
- Add a horizontal rule (`<hr>`) and an `<h1>` tag labeled "Posts".
- Render the `PostList` component below these elements.

In `PostList.js`, we need to:
1. Fetch a list of posts from the Post service.
2. Store posts using React state.
3. Display each post's title in a styled card.

Start by importing the required modules:
- Import `useState` and `useEffect` from React.
- Import Axios for making HTTP requests.

Define a state variable for storing posts:
- Use `useState` to create a `posts` state variable with an initial value of an empty object.

Define a function to fetch posts:
- Use an `async` function named `fetchPosts`.
- Make a GET request to `http://localhost:4000/posts`.
- Extract the `data` from the Axios response and update the `posts` state using `setPosts`.

Call `fetchPosts` using `useEffect`:
- Use `useEffect` to ensure `fetchPosts` runs only once when the component mounts.
- Pass an empty dependency array to `useEffect` to achieve this.

Verify the fetched data:
- Add a `console.log(posts)` after the `fetchPosts` call.
- Confirm that the data matches the structure expected from the Post service.

Render posts:
- Use `Object.values(posts)` to iterate over the post objects.
- For each post, return a `<div>` with a `key` set to `post.id`.
- Style the `<div>` as a card with inline CSS and class names for layout and appearance.
- Inside the card, display the post title using an `<h3>` tag.

Finalize the component:
- Wrap the rendered posts in a parent `<div>`.
- Add class names to the parent `<div>` for styling and layout (e.g., `d-flex`, `flex-wrap`, `justify-content-between`).

Test the implementation:
- Ensure the posts appear as cards on the screen.
- Create new posts using the PostCreate component and manually refresh the page to see the updates.
- Note that real-time updates will require additional logic.

Next steps will involve implementing the commenting functionality, starting with displaying and creating comments.


//---------------- 11. Creating Comments

Two new components need to be created: `CommentCreate` and `CommentList`. These are similar to previously created components.

`CommentCreate`:
1. Start with a new file `CommentCreate.js`.
2. Import React and create the component:
   ```jsx
   import React, { useState } from 'react';

   const CommentCreate = ({ postId }) => {
       const [content, setContent] = useState('');

       const onSubmit = async (e) => {
           e.preventDefault();
           await axios.post(`http://localhost:4001/posts/${postId}/comments`, { content });
           setContent('');
       };

       return (
           <div>
               <form onSubmit={onSubmit}>
                   <div className="form-group">
                       <label>New Comment</label>
                       <input
                           value={content}
                           onChange={(e) => setContent(e.target.value)}
                           className="form-control"
                       />
                   </div>
                   <button className="btn btn-primary">Submit</button>
               </form>
           </div>
       );
   };

   export default CommentCreate;
   ```

3. Component represents a form where users can type and submit a comment.
4. Requires the `postId` prop to associate the comment with a specific post.
5. On form submission, makes a POST request to the comments microservice using `axios`.
6. Clears the input field after successful submission.

Adding `CommentCreate` to `PostList`:
1. Import `CommentCreate` in `PostList.js`.
   ```jsx
   import CommentCreate from './CommentCreate';
   ```
2. Add `CommentCreate` below each post in the `PostList` component:
   ```jsx
   {posts.map(post => (
       <div className="card" key={post.id}>
           <div className="card-body">
               <h3>{post.title}</h3>
               <CommentCreate postId={post.id} />
           </div>
       </div>
   ))}
   ```
3. Each instance of `CommentCreate` is passed the corresponding `postId`.

Testing:
1. Run the app.
2. Verify that the comment form appears under each post.
3. Enter a comment, submit, and confirm it is successfully sent to the backend by checking network requests.
4. Ensure the input field clears after submission.

Next, proceed to create the `CommentList` component.

//---------------- 12. Displaying Comments

Comment List Component Notes:

- The goal is to manage the comment list component, allowing it to fetch and display comments for a post.
- At the top of the file, import `React`, `useState`, `useEffect`, and `Axios`.

Steps:
1. Create a new file named `CommentList.js` in the `src` directory.
2. Define a React functional component and export it by default.
3. Initialize an empty div in the return statement as a placeholder.

Responsibilities of the Component:
- Manage its own data by fetching comments from the comment microservice.
- The API endpoint used is `/posts/:postId/comments`, which returns an array of comments for a given post.
- The post ID needs to be passed down as a prop from the parent component (`PostList`).

Implementation:
- Import necessary hooks and libraries: `useState`, `useEffect`, and `Axios`.
- Define a state variable `comments` using `useState`, initializing it to an empty array since the API returns an array of comments.
- Define an `async` function `fetchData` to fetch comments from the API.
  - Use `Axios` to make a GET request to `http://localhost:4001/posts/${postId}/comments`.
  - Update the `comments` state using the response data.
- Use `useEffect` to call `fetchData` when the component mounts. Add an empty dependency array to ensure it runs only once.

Rendering:
- Map over the `comments` state to generate a list of `li` elements, each displaying the `content` of a comment.
- Assign a unique `key` to each `li` using the `id` of the comment.
- Wrap the list in a `ul` and return it in the render method.

Integration:
- Import `CommentList` in `PostList`.
- Render `CommentList` for each post inside the `PostList` component's mapping function.
- Pass the `postId` of each post as a prop to the `CommentList` component.

Testing:
- Test by adding and displaying comments for posts.
- Refresh the page to see the comments since no reload logic is currently implemented.
- Ensure that comments are displayed correctly and associated with the correct post.

Observation:
- For every post, a separate API request is made to fetch comments. This can lead to inefficiencies with a larger dataset.
- Highlight this issue in the next video to explore potential optimizations.



//---------------- 13. Request Minimization Strategies

To optimize the inefficiency in our current implementation, we need to address how we fetch posts and their associated comments. 

Currently, for every post fetched, a separate request is made to the comment service to retrieve comments. This results in multiple requests—one for each post—which is inefficient.

The goal is to condense this into a single request that fetches all posts along with their associated comments.

If this were a monolithic architecture, solving this would be straightforward:
- A single GET request to `/posts` with a query like `?comments=true` could return all posts with embedded comments.

However, since we're using microservices, the challenge is more complex. Our options are:
1. Synchronous Communication:
   - The post service would make a request to the comment service for each post ID.
   - The comment service would reply with comments, which the post service combines with the relevant posts before sending the response to the browser.

   Downsides:
   - Dependency: The post service becomes dependent on the comment service. If the comment service is down, the post service fails.
   - Latency: Adds a round-trip delay between services, slowing down the response to the browser.
   - Scalability Issues: As more services are added, the system may create a chain of dependent requests, increasing the risk of failures and further delays.

2. Alternative Solution:
   - This approach avoids synchronous communication and its downsides.
   - We will explore this in the next part of the lecture.

The synchronous communication method, while conceptually simple, introduces engineering challenges and potential bottlenecks. An alternative strategy is necessary to build a more robust and scalable system.



//---------------- 14. An Async Solution

Using synchronous communication to solve the problem is easy to understand but not the best engineering solution. 
In this video, we explore an alternative using asynchronous communication.

Asynchronous communication often involves an event broker, which routes notifications (events) between services. 
Here, we introduce a query service to handle and consolidate data efficiently.

The query service listens for events emitted by other services. For example:
- When a post is created, the post service emits a "post created" event containing the post's ID and title.
- This event is sent to the event bus, which forwards it to the query service.
- The query service processes the event and stores the post data, initializing a data structure that includes the post and an empty array for comments.

Similarly:
- When a comment is created, the comment service emits a "comment created" event with the comment's ID, content, and related post ID.
- The event bus forwards this to the query service.
- The query service locates the relevant post and appends the comment to its comments array.

The query service can then respond to a single GET request from the client with all posts and their associated comments. 
This eliminates the need for multiple requests between services.

Pros of this asynchronous approach:
- The query service has no direct dependencies on other services. It continues functioning even if other services fail.
- It is much faster, as there are no inter-service requests during a client query.
- It simplifies client-side operations with a single efficient request.

Cons:
- Data duplication occurs, as posts and comments are stored both in their respective services and in the query service. 
  However, this redundancy can be beneficial and will be discussed later.
- The implementation is complex, requiring awareness of all events and careful design of event processing.

While harder to implement, the operational efficiency of this approach is superior, with fewer dependencies and faster query responses. 
If any other service goes down, the query service remains functional.

In the next video, we'll address some common concerns and questions about this approach. Stay tuned!



//---------------- 15. Common Questions Around Async Events

We’ve reviewed asynchronous communication multiple times, and now we’re addressing some common questions.

1. Do we need a third service to join data (e.g., posts and comments)?
   - Not necessarily. In a real-world scenario, related data like posts and comments could often exist within the same service to allow data joining at the code level. 
   - The current example is purely educational, demonstrating how to store and replicate data across services.

2. Why does service independence matter if crashes are rare?
   - Microservices aim to enhance system reliability. Independence ensures most parts of the application remain functional even if one service fails.
   - Reliability is a key reason for using microservices, and this architecture supports that goal.

3. Is this architecture too complex for the benefits it offers?
   - While it feels complex now, event-based architecture simplifies adding new features later.
   - As the application grows, this approach can handle complexity more effectively than monolithic or synchronous communication methods.

4. What about special cases or corner scenarios?
   - Event-based architectures introduce unique challenges and corner cases.
   - We’ll address these corner cases in-depth later in the course, providing solutions for many.
   - If issues aren’t apparent now, don’t worry; understanding evolves with experience.

With these clarifications in mind, we’ll move forward to implement:
- The new query service.
- The event bus.
- Service communication via events.

Implementation starts in the next video.


//---------------- 16. Event Bus Overview

Notes on Event Bus Design:

1. Purpose of the Event Bus:
   - Facilitates communication of events between different services.
   - Allows one service to emit an event and others to listen to it.

2. Building the Event Bus:
   - It will be built from scratch using JavaScript and Express.
   - Focus on understanding the underlying mechanisms, not on advanced features.

3. Event Bus Implementations:
   - Examples: RabbitMQ, Kafka, NATS, etc.
   - These are open-source projects with features to receive and publish events to listeners.
   - Events can be any data format (JSON, raw bytes, strings, etc.).

4. Listeners:
   - Other services listening to events emitted by the event bus.

5. Trade-offs with Different Event Buses:
   - Various implementations have unique features making some tasks easier or harder.
   - It's crucial to evaluate which implementation suits your application's needs.

6. Simplistic Design Approach:
   - The event bus being built in this project will be extremely simple.
   - It won't have the extensive features of production-grade event buses.
   - The goal is to understand the flow of data and mechanics.

7. How the Event Bus Works:
   - Services will have routes that handle POST requests to `/events`.
   - When a service emits an event, it will send a POST request to the event bus.
   - The event bus will:
     - Receive the event.
     - Forward the event to all services (including the originating service) via POST requests.

8. Flow of Events:
   - Example:
     - A service emits an event via a POST request to the event bus.
     - The event bus forwards the event to:
       - `http://localhost:4000/events` (Post service)
       - `http://localhost:4001/events` (Another service)
       - `http://localhost:4002/events` (Another service)
     - The event is identical in all forwarded requests.

9. Purpose of Building a Custom Event Bus:
   - Provides a clear understanding of the data flow.
   - Simplifies debugging and learning about inter-service communication.

10. Next Steps:
    - Start coding the event bus implementation.
    - Understand and implement the basic POST request handling for event broadcasting.


//---------------- 17. A Basic Event Bus Implementation

Notes on Event Bus Implementation:

1. Creating the Event Bus Directory:
   - Inside the main project directory (e.g., "blog"), create a new folder named `event-bus`.
   - Open a terminal for this new directory.

2. Setting Up the Project:
   - Initialize the project: `npm init -y`.
   - Install dependencies: `npm install express body-parser axios`.

3. Project Structure:
   - Create an `index.js` file inside the `event-bus` folder.

4. Initial Setup in `index.js`:
   - Import required modules: `express`, `body-parser`, and `axios`.
   - Create an Express application.
   - Use `body-parser` middleware to handle JSON data: `app.use(bodyParser.json());`.

5. Implementing the `/events` Endpoint:
   - Create a POST request handler for the `/events` path.
   - Extract the incoming event from `req.body`.
   - Forward the event to other services using Axios POST requests:
     - `http://localhost:4000/events` (Post Service)
     - `http://localhost:4001/events` (Comments Service)
     - `http://localhost:4002/events` (Query Service)
   - Send a response indicating success: `res.send({ status: 'OK' });`.

6. Error Handling Note:
   - The current implementation assumes all POST requests will succeed.
   - There’s no handling for failed requests, which will be addressed later.

7. Starting the Server:
   - Set the app to listen on port `4005`.
   - Log a message: `console.log('Listening on 4005');`.

8. Updating `package.json`:
   - Modify the `scripts` section to include a start script:
     - `"start": "nodemon index.js"`.

9. Running the Event Bus:
   - Open a terminal for the `event-bus` directory.
   - Run the start script: `npm start`.
   - Verify the server is running with the message `Listening on 4005`.

10. Next Steps:
    - Implement event emission in other services (Post and Comments) to send events to the event bus.
    - Ensure smooth integration and event forwarding. 


//---------------- 18. Emitting Events

Notes:

- Initial implementation of the event bus has been set up.
- The event bus will handle requests from services like the postal service and common service whenever significant events occur, such as creating a new post or comment.
- The event bus will echo these events to all services running in the application.

- Current Status:
  - Services lack the necessary `post /events` endpoint.
  - Requests sent to these endpoints fail with a 404 error.
  - Next step: Implement these endpoints to allow services to listen to events emitted by the event bus.

- Focus for now:
  - Ensure the post service emits an event whenever a new post is created.

- Development Workflow:
  - Open all service directories in one editor for easier navigation.
  - Locate the `index.js` file of the post service.
  - Add Axios as a dependency to handle HTTP requests.

- Implementation Steps:
  1. Identify the post creation endpoint.
  2. Use Axios to emit an event after a new post is added to the collection.
     - Event structure:
       - `type`: Describes the event (e.g., `PostCreated`).
       - `data`: Contains additional information, such as the created post (ID and title).
  3. Add async/await to handle the asynchronous request.

- Event Design:
  - Events should have a consistent structure: a `type` property and a `data` property.
  - Flexibility to include any data structure, but consistency is preferred.

- Testing:
  - Restart the post service (posts stored in memory will disappear upon restart).
  - Create a new post and verify its presence by refreshing the React application.
  - Check terminal logs:
    - Post service should log the emitted event.
    - Event bus logs should show any 404 errors when sending the event to unimplemented endpoints.

- Observations:
  - Errors (status 404) are expected since other services lack the `post /events` endpoint.
  - Event emission from the post service to the event bus is functioning as intended.

- Next Steps:
  - Implement `post /events` endpoints in all services to handle received events.
  - Continue refining the event schema and ensuring consistency across services.

//---------------- 19. Emitting Comment Creation Events

Notes:

- Objective:
  - Ensure that the comment service emits an event to the event bus whenever a new comment is created.

- Event Structure:
  - `type`: "CommentCreated"
  - `data`: Includes the comment details:
    - `id`: Comment ID
    - `content`: Content of the comment
    - `postId`: ID of the post the comment is tied to

- Process Overview:
  - Event bus will broadcast the emitted event to all services.
  - 404 errors are expected since other services do not yet have endpoints to receive these events.

- Steps to Implement:
  1. Open the `index.js` file inside the comments service directory.
  2. Import Axios at the top of the file to handle HTTP requests.
  3. Locate the code handling the creation of a new comment.
  4. After saving the new comment, add the following code to emit an event:
     ```javascript
     await axios.post('http://localhost:4005/events', {
         type: 'CommentCreated',
         data: {
             id: comment.id,
             content: comment.content,
             postId: req.params.id
         }
     });
     ```
  5. Use `async/await` for asynchronous operations.

- Testing:
  - Create a new comment in the application.
  - Verify that the comment appears after refreshing the page.
  - Check terminal logs to confirm the event bus is emitting events.
  - Observe 404 errors, which are expected at this stage.

- Observations:
  - Two services (post service and comment service) now emit events for significant actions.
  - Services currently do not have endpoints to process received events.
  - Query service, once created, will handle and process incoming events that are relevant.

- Next Steps:
  - Implement event handlers in all services to process emitted events.
  - Develop the query service to manage and react to incoming events.


//---------------- 20. Receiving Events

Notes:

- Objective:
  - Add event handlers for the post service and comment service to handle incoming events from the event bus.

- Steps to Implement for Post Service:
  1. Open the `index.js` file inside the post service directory.
  2. At the bottom of the file, above the `listen` method, add a new POST request handler for the `/events` route.
  3. Log the received event type for debugging purposes:
     ```javascript
     app.post('/events', (req, res) => {
         console.log('Event Received:', req.body.type);
         res.send({});
     });
     ```

- Steps to Implement for Comment Service:
  1. Open the `index.js` file inside the comment service directory.
  2. At the bottom of the file, above the `listen` method, add a new POST request handler for the `/events` route.
  3. Log the received event type for debugging purposes:
     ```javascript
     app.post('/events', (req, res) => {
         console.log('Event Received:', req.body.type);
         res.send({});
     });
     ```

- Testing the Implementation:
  1. Restart all services to ensure the changes are applied.
  2. In the browser, create a new post and add comments to it.
  3. Verify that:
     - The post and comments are displayed after refreshing the page.
     - Logs in the terminal show received events for both post and comment services.
  4. Confirm 404 errors from the event bus when trying to send events to non-existent endpoints (e.g., query service).

- Observations:
  - The post service and comment service can now receive and log incoming events.
  - Event bus successfully broadcasts events to all services.
  - 404 errors are expected for services that do not yet exist or handle events.

- Next Steps:
  - Implement the query service to listen for `PostCreated` and `CommentCreated` events.
  - Process incoming events to assemble a usable data structure for the application.
  - Ensure the query service handles data aggregation as planned in the diagrams.