//---------------- 1. App Overview

Now that we've covered the communication patterns with microservices, we’re diving into actual code.

Goal of this project: 
- Get hands-on experience with microservices architecture.
- Build as much as possible from scratch to understand what’s going on.

This is a simple application to showcase the patterns:
- It's not meant to be a template for future projects because in real-world projects we use packages instead of building everything manually.
- This application is just a starting point. A more complex project will come later in the course.

What are we building?
- A simple blog-like application where users can create posts and add comments to them.
- Posts will only have titles for simplicity (no body content).
- After creating a post, the title will be displayed with the number of comments.
- Users can add comments, and the number of comments for each post will increment.

Technical Breakdown:
- We’ll need two types of services: 
  - Post Service: Handles creating and listing posts.
  - Comment Service: Handles creating and listing comments.

Service Responsibilities:
- Post Service: 
  - Create a post
  - List all posts
- Comment Service: 
  - Create a comment tied to a specific post
  - List comments associated with a post

Hidden Complexity:
- The Comment Service will have complexity because it needs to link comments to posts.
- To create a comment, the system needs to know what posts exist, so it will need to use asynchronous or synchronous communication.
- When listing comments, they should be filtered by the posts they are tied to (i.e., retrieving comments for the top 10 most popular posts).

Even though the app seems simple, the underlying structure will introduce challenges. These complexities will become clearer as we start implementing the services.


//---------------- 2. Project Setup

We are starting to set up our project and will quickly review the architecture and initial setup steps.

Architecture Overview:
- The browser will run a React application.
- The React application communicates with two services via network requests:
  - Post Service
  - Comment Service
- Both services are Express-based applications.
- For this project, data will be stored in memory (no databases) to keep the focus on understanding communication patterns.

Setup Plan:
1. Create a React application using Create React App.
2. Scaffold two Express-based services: Post Service and Comment Service.
3. Use three terminal windows to manage the setup:
   - One for the React client.
   - One for the Post Service.
   - One for the Comment Service.

Steps:
- In the terminal, navigate to your workspace directory and create a folder named `blog` to hold the entire project.
- Generate the React application:
  - Run `npx create-react-app client` to create the client directory for the React app.
- While the React app installs, set up the Post Service:
  - Create a `posts` folder inside the `blog` directory.
  - Navigate to the `posts` folder.
  - Initialize a `package.json` file using `npm init -y`.
  - Install dependencies: `npm install express cors axios nodemon`.
- Repeat the same process for the Comment Service:
  - Create a `comments` folder inside the `blog` directory.
  - Navigate to the `comments` folder.
  - Initialize a `package.json` file using `npm init -y`.
  - Install dependencies: `npm install express cors axios nodemon`.

Managing Terminal Windows:
- Ensure you have three terminal windows:
  - One in the `client` directory for the React app.
  - One in the `posts` directory for the Post Service.
  - One in the `comments` directory for the Comment Service.
- Keep track of which terminal window corresponds to which part of the project.

Note:
- Managing multiple terminal windows can be confusing, so stay organized and aware of the active terminal.
- To simplify switching between windows, you might consider tiling them for better visibility in the next steps.

This concludes the initial setup. We'll begin writing code in the upcoming steps.


//---------------- 3. Posts Service Creation

We have done some initial setup and are ready to start writing our services for the implementation.

For now, we will focus on basic functionality for the Post service.

The goal is to:
- Create a post.
- List all posts.

Key routes for the Post service:
1. A route to retrieve all posts (GET /posts).
2. A route to create a new post (POST /posts).

Plan:
- Use Express to build a small application.
- Define two route handlers.
- Store posts in memory (not using a database for this toy project).

Steps:
1. Require Express and create an application.
2. Define the two routes: GET /posts and POST /posts.
3. Set up the application to listen on port 4000.
4. Implement an in-memory object to store posts.
5. Handle GET requests by sending all posts.
6. Handle POST requests by:
   - Generating a random ID for the new post using the `crypto` module's `randomBytes` function.
   - Extracting the title from the request body.
   - Adding the new post to the in-memory object.
   - Responding with the newly created post's ID.
7. Add a body parser middleware to parse JSON data in incoming requests.

Implementation notes:
- Create a file (index.js) to write the code.
- Use `body-parser` middleware for JSON handling.
- Add a script to package.json to start the application with `nodemon`.

Final steps:
- Test the service after implementation.
- Verify it is running on port 4000 by checking the logs.


//---------------- 4. Testing the Posts Service

We've now finished up our first post service.

It's time to test this manually before diving into automated testing later in the course. Automated testing is crucial for microservices, and we’ll cover it in detail as we proceed. For now, we'll use manual testing to ensure the service is functioning as expected.

To test the service manually, we’ll use Postman, a desktop application that allows you to make arbitrary API requests to any endpoint. If you don’t want to use Postman, you can use an alternative, but Postman simplifies the process significantly.

If you don’t already have Postman installed, download it from postman.com. Once installed, open Postman, and you’ll see its main interface. Here’s how we’ll test the post service:

1. Open a new tab in Postman to customize an API request.
2. Set the HTTP method to POST and the URL to `http://localhost:4000/posts`.
3. Navigate to the Headers tab and add a new header with:
   - Key: `Content-Type`
   - Value: `application/json`
4. Go to the Body tab and select the “raw” option. Ensure the dropdown on the right is set to JSON.
5. Write JSON data in the request body. For example:
   ```json
   {
       "title": "First Post"
   }
   ```
6. Send the request. You should receive a response with status `201 Created` and a JSON object containing the ID and title of the post you just created.

Next, test retrieving all posts:

1. Open another new tab in Postman.
2. Set the HTTP method to GET and the URL to `http://localhost:4000/posts`.
3. In the Headers tab, ensure the `Content-Type` header is set to `application/json`.
4. Send the request. You should see a JSON response with all the posts created so far.

Be mindful that the service stores posts in memory. If you make any code changes, the server will restart, and all posts will be lost. For example, adding a simple comment and saving the file will trigger a restart (if using Nodemon). If you then make a GET request, no posts will be returned.

While manual testing is a good start, we’ll rely on automated testing as we build more services. In the next video, we’ll start developing the comment service. You’ll be encouraged to test it with Postman as we’ve done here to verify functionality.

//---------------- 5. Implementing a Comments Service

We finished up our post service, so now we're going to put together an initial implementation of our comments service.

Just as we did before, it's worth our time to thoroughly define what we want our comments service to do. 

For the comments service, we'll have two different route handlers:
1. A handler to create a new comment associated with a specific post. This involves:
   - Making a POST request to `post/:id/comments`.
   - Including a request body with a `content` field for the comment text.
2. A handler to retrieve all comments for a specific post. This involves:
   - Making a GET request to `post/:id/comments`.

The comments service will require some additional complexity in its design. We'll store comments in an in-memory data structure called `commentsByPostId`, optimized for retrieving all comments associated with a specific post.

Implementation Plan

1. Setup
   - Create an `index.js` file in the `comments` directory.
   - Import the necessary libraries: `express`, `body-parser`, and `crypto` for generating random IDs.
   - Initialize an Express app and configure `body-parser` as middleware.

2. Define Routes
   - Implement a POST route at `/post/:id/comments` to handle new comment creation:
     - Generate a unique comment ID using `crypto.randomBytes`.
     - Extract the `content` from the request body.
     - Check if comments exist for the given post ID in `commentsByPostId`. If not, initialize an empty array.
     - Add the new comment (ID and content) to the array and update the `commentsByPostId` object.
     - Return the updated array of comments.
   - Implement a GET route at `/post/:id/comments` to retrieve comments for a specific post:
     - Look up the post ID in `commentsByPostId`.
     - If no comments are found, return an empty array.
     - Respond with the array of comments.

3. Start Server
   - Ensure the server listens on a unique port (e.g., `4001`) since the post service is already using `4000`.
   - Log a confirmation message when the server starts.

4. Data Structure Overview
   - The `commentsByPostId` object will have:
     - Keys representing post IDs.
     - Values as arrays containing comments for the corresponding post.
   - This design allows quick retrieval of all comments for a specific post.

Example Data Flow

For a post ID `123`:
- `commentsByPostId` might look like this:
  ```json
  {
      "123": [
          { "id": "c1", "content": "Great post!" },
          { "id": "c2", "content": "Thanks for sharing." }
      ]
  }
  ```

5. Testing
   - Use Postman to manually test the POST and GET endpoints:
     - For POST: Verify that new comments are added correctly.
     - For GET: Confirm retrieval of all comments for a post.
   - Ensure appropriate response statuses (e.g., `201 Created` for POST).

In the next steps, we'll perform manual testing using Postman and refine the service based on observed behavior. Automated testing will follow later in the course.

//---------------- 6. Quick Comments Test

Our combat service is all complete, so let's very quickly do a quick test using Postman. Start by flipping back over to the terminal to get started.

1. Find the terminal window inside the comments project directory and start the service.
2. Recall that there are two separate services running on your machine:
   - One listening on Port 4000.
   - The other listening on Port 4001.

To communicate with the comments service, make requests to localhost:4001.

Testing with Postman

1. Post Request to Create a Comment
   - Open Postman and create a new request tab.
   - Set the request type to POST.
   - Enter the URL: `http://localhost:4001/posts/123/comments`. The post ID `123` can be any string for testing since the service doesn’t validate IDs.
   - Add headers:
     - `Content-Type: application/json`.
   - In the Body section:
     - Select `Raw` and ensure the dropdown is set to JSON.
     - Add JSON content, for example:
       ```json
       {
           "content": "I am a comment"
       }
       ```
   - Send the request. A successful response (201 Created) should include an array of comments for the post ID.

2. Get Request to Retrieve Comments
   - Open another request tab in Postman.
   - Set the request type to GET.
   - Enter the URL: `http://localhost:4001/posts/123/comments`.
   - Add headers:
     - `Content-Type: application/json`.
   - Send the request. A successful response (200 OK) should return an array of comments for the given post ID.

3. Add Additional Comments
   - Go back to the POST request tab.
   - Update the comment content to "Second comment".
   - Send the request again. The response should now show two comments.
   - Verify by returning to the GET request tab and sending the request again to ensure all comments are retrieved.

Notes

- The comments service correctly handles adding multiple comments without overwriting existing ones.
- This concludes basic testing with Express.js.

In the next session, we'll build the React application. During this process, potential design issues in our current implementation will become evident. We'll address these problems using a microservices approach to improve efficiency and scalability.


//---------------- 7. React Project Setup

We've now got our two services put together, so now it's time to start working on our React application.

If you don't know React or don't want to work with it, you can skip these videos and download the completed React app in a couple of videos. Any changes required to the React project later will be minimal.

Component Design
The app will have the following component hierarchy:
- `App`: The top-level component.
- `PostCreate`: Displays the form for creating posts.
- `PostList`: Displays all posts.
- `CommentList`: Displays comments associated with a post.
- `CommentCreate`: Displays the form for creating comments.

Each component will have its specific responsibilities:
- `PostCreate` handles creating posts.
- `PostList` shows posts and integrates `CommentList` and `CommentCreate` for each post.
- `CommentList` lists all comments for a post.
- `CommentCreate` handles adding new comments.

Setting Up the Project
1. Navigate to the `client` directory where the React project is located.
2. Open your code editor inside this directory.
3. Run `npm install` to install dependencies. Install Axios for making API requests:
   ```bash
   npm install axios
   ```
4. Start the React development server:
   ```bash
   npm start
   ```

Cleaning Up
1. Open the `src` directory and delete all boilerplate code to start from scratch.
2. Create the following files in `src`:
   - `index.js`
   - `App.js`

Building the Application
#`App.js`
```jsx
import React from "react";

const App = () => {
    return <div>Blog App</div>;
};

export default App;
```

#`index.js`
```jsx
import React from "react";
import ReactDOM from "react-dom";
import App from "./App";

ReactDOM.render(<App />, document.getElementById("root"));
```

Testing the Setup
1. Restart the development server to apply the changes.
2. Ensure that the app renders the text "Blog App" in the browser.

This concludes the initial setup. Next, we’ll start implementing the component hierarchy and connecting our React app to the Express APIs.


//---------------- 8. Building Post Submission

We've now got our two services put together, so now it's time to start working on our React application.

If you don't know React or don't want to work with it, you can skip these videos and download the completed React app in a couple of videos. Any changes required to the React project later will be minimal.

Component Design
The app will have the following component hierarchy:
- `App`: The top-level component.
- `PostCreate`: Displays the form for creating posts.
- `PostList`: Displays all posts.
- `CommentList`: Displays comments associated with a post.
- `CommentCreate`: Displays the form for creating comments.

Each component will have its specific responsibilities:
- `PostCreate` handles creating posts.
- `PostList` shows posts and integrates `CommentList` and `CommentCreate` for each post.
- `CommentList` lists all comments for a post.
- `CommentCreate` handles adding new comments.

Setting Up the Project
1. Navigate to the `client` directory where the React project is located.
2. Open your code editor inside this directory.
3. Run `npm install` to install dependencies. Install Axios for making API requests:
   ```bash
   npm install axios
   ```
4. Start the React development server:
   ```bash
   npm start
   ```

Cleaning Up
1. Open the `src` directory and delete all boilerplate code to start from scratch.
2. Create the following files in `src`:
   - `index.js`
   - `App.js`

Building the Application
#`App.js`
```jsx
import React from "react";

const App = () => {
    return <div>Blog App</div>;
};

export default App;
```

#`index.js`
```jsx
import React from "react";
import ReactDOM from "react-dom";
import App from "./App";

ReactDOM.render(<App />, document.getElementById("root"));
```

Testing the Setup
1. Restart the development server to apply the changes.
2. Ensure that the app renders the text "Blog App" in the browser.

Creating the PostCreate Component
1. In the `src` directory, create a new file `PostCreate.js`.
2. Implement the component as follows:

#`PostCreate.js`
```jsx
import React, { useState } from "react";
import axios from "axios";

const PostCreate = () => {
    const [title, setTitle] = useState("");

    const onSubmit = async (event) => {
        event.preventDefault();
        await axios.post("http://localhost:4000/posts", { title });
        setTitle("");
    };

    return (
        <div>
            <form onSubmit={onSubmit}>
                <div className="form-group">
                    <label>Title</label>
                    <input
                        value={title}
                        onChange={(e) => setTitle(e.target.value)}
                        className="form-control"
                    />
                </div>
                <button className="btn btn-primary">Submit</button>
            </form>
        </div>
    );
};

export default PostCreate;
```

3. Update `App.js` to include `PostCreate`:

#`App.js`
```jsx
import React from "react";
import PostCreate from "./PostCreate";

const App = () => {
    return (
        <div className="container">
            <h1>Create Post</h1>
            <PostCreate />
        </div>
    );
};

export default App;
```

Adding Bootstrap
1. Link Bootstrap CSS in `public/index.html`:
```html
<link
    href="https://cdn.jsdelivr.net/npm/bootstrap@5.1.3/dist/css/bootstrap.min.css"
    rel="stylesheet"
    integrity="sha384-1BmE4kWBq78iYhFldvKuhfTAU6auUHI6WlZKmIOTa1HsENBO0LRn5q+8nbTov4+1"
    crossorigin="anonymous"
/>
```

2. Add a `container` class to the main `div` in `App.js` to constrain the layout.

Testing PostCreate
1. Open the browser’s developer tools and navigate to the network tab.
2. Create a post by entering a title and clicking submit.
3. Check for a POST request to `http://localhost:4000/posts`.
4. If there’s a CORS error, this will be addressed in the next video.

This concludes the implementation of the `PostCreate` component.